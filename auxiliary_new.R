#  
# Auxiliary functions for logbarrier, intpoint and probadap
#
# Version:  1.1
# Date:     May 2004
# Author:   Kaspar Rufibach (Supported by Schweizer Nationalfonds)
# 
# Source:
# - Kaspar Rufibach (2004).
#   Computing ML-Estimators of a log-concave density function.
#   Preprint

#=========================== vek.len(v) =========================================================
# Calculates euclidean length of the vector v   
vek.len <- function(v){sqrt(sum(v^2))}

#=========================== pool(x,gap) ========================================================
# Pools x-values which are closer than gap   
pool <- function(x,gap=10^-4){
  n <- length(x)
  x2 <- sort(x)
  x3 <- c()
  w <- c()
  temp <- x2[1]
  for (i in 2:n){
    if ((x2[i]-mean(temp))<=gap){temp <- c(temp,x2[i])} else {
      if (length(temp)>1){
        x3 <- c(x3,mean(temp))
        w <- c(w,length(temp))
        temp <- x2[i]} else {
          temp <- x2[i]
          x3 <- c(x3,x2[i-1])
          w <- c(w,1)}
    }}
  if (length(temp)>0){
    x3 <- c(x3,mean(temp))
    w <- c(w,length(temp))}
  
  list(x3,w)}     

#=========================== mu.calc(m,s,v,rho,sig) =============================================
# Calculates mu in the interior point algorithms
mu.calc <- function(m,s,v,rho,sig){
  temp <- (t(v)%*%s)/m
  E <- min(v*s)/temp
  if (E>=sig){mu <- rho/(t(v)%*%s+rho)*temp}
  else {mu <- temp}
  mu} 

#=========================== kern(x) ============================================================
# kern(x) : calculates standard kernel density estimator at the observations x
kern <- function(x){
  x <- sort(x)
  n <- length(x)
  K <- function(x){1/sqrt(2*pi)*exp(-x^2/2)}
  h <- 1.06*sqrt(var(x))*length(x)^(-1/5)
  f <- NULL
  for (i in 1:n){f[i] <- sum(K((x[i]-x)/h))/(n*h)}
  f}

#=========================== plot.dens/logdens/dist(x,f) ========================================
# Functions to plot estimated density function, distribution function derived from the estimator 
# and the logarithm phi of the estimated density function
# Input: list generated by one of the three algorithm functions

plot.dens <- function(result){
  x <- result[[1]]$x
  f <- result[[1]]$f
  n <- length(x)
  dx <- c(0,diff(x))
  phi <- log(f)
  
  d <- kern(x)
  xlimi <- range(x)
  ylimi <- max(d,f)
  plot(x,f,xlim=xlimi,ylim=c(-0.05,ylimi),main='Estimated density',xlab='x',ylab='f(x)',lty=1,type='l')
  lines(x,d,lty=3,type='l')
  legend(0.62*max(x),0.92*ylimi,c('estimated density','kernel estimator'),lty=c(1,3))  
  for (i in 1:length(x)){segments(x[i],-0.01,x[i],-0.05)}
}

plot.logdens <- function(result){
  x <- result[[1]]$x
  f <- result[[1]]$f
  n <- length(x)
  dx <- c(0,diff(x))
  phi <- log(f)
  
  plot(x,phi,ylim=c(min(phi)-0.07*diff(range(phi)),max(phi)),type='l',main='Logarithm of estimated density',ylab='phi(x)',xlab='x')
  for (i in 1:length(x)){segments(x[i],min(phi)-0.02*diff(range(phi)),x[i],min(phi)-0.06*diff(range(phi)))}           
}

plot.dist <- function(result){
  x <- result[[1]]$x
  f <- result[[1]]$f
  n <- length(x)
  dx <- c(0,diff(x))
  phi <- log(f)
  
  w.tab <- table(x)
  w.unique <- as.numeric(names(w.tab))
  quant <- seq(min(w.unique),max(w.unique),by=abs(range(w.unique)[2]-range(w.unique)[1])/1000)
  w.freq <- as.vector(w.tab)
  F.values <- cumsum(w.freq)/sum(w.freq)
  w.unique <- c(min(w.unique)-1/2,w.unique,max(w.unique)+1/2)
  F.values <- c(0,F.values,1)           
  
  plot(x,cumsum(dx*f),xlim=range(w.unique),ylim=c(0,1),type='l',lty=1,xlab='x',ylab='F(x)',main=paste('Distribution derived from estimated density'))
  legend(min(x),1,c('estimation','empirical distribution'),lty=c(1,3))
  lines(w.unique,F.values,type='s',lty=3)                             
  for (i in 1:length(x)){segments(x[i],-0.01,x[i],-0.05)}             
}

#=========================== plot.LL(LL) ======================================================
# Plots shape of the log-likelihood function
# Input: list generated by one of the three algorithm functions

plot.LL <- function(result){
  LL <- result[[2]]
  plot(LL,type='l',lty=1,xlab='Number of iteration',ylab='Values of log-likelihood',main='Shape of log-likelihood function',xaxt='n')
  axe <- c(1,1:round(length(LL)/10,0)*10,max(length(LL)))
  axis(1,at=axe,labels=axe)
  text(0.8*max(length(LL)),max(LL),paste('min: ',round(min(LL),3),'   max:',round(max(LL),3)))}

#####################################################
# Auxiliary functions for logbarrier and intpoint #
#####################################################

#================= phieta.par1(x,phi), etaphi.par1(x,eta) ===================================
# Changes between different parametrisations
phieta.par1 <- function(x,phi){ 
  n <- length(x)
  eta <- c(phi[1],diff(phi)/diff(x))
  eta}

etaphi.par1 <- function(x,eta){
  n <- length(x)
  dx <- c(0,diff(x))
  phi <- eta[1]+c(0,cumsum(dx[2:n]*eta[2:n]))
  phi}

#================= starter.par1(x) ==========================================================
# start vector: fitted values for a model log(kern(x))~1+x+log(x) (corresponds to Gamma density)
starter.par1 <- function(x){
  X <- cbind(1,x,x^2)
  H <- X%*%solve(t(X)%*%X)%*%t(X)
  phi <- H%*%(log(kern(x)))
  
  # it can happen that phi is convex instead of concave (e.g. when the true density is uniform)
  d <- diff(phi)/diff(x)
  if (d[2]<d[3]){phi <- -phi}
  
  eta <- phieta.par1(x,phi)
  eta}

#============= penalties:(log(eta_i-eta[i-1]) ===============================================
pen.par1 <- function(eta){
  n <- length(eta)    
  i <- 2:(n-1)
  sum(log(eta[i]-eta[i+1]))}

diff.pen.par1 <- function(eta){
  n <- length(eta)    
  i <- 3:(n-1)
  c(0,1/(eta[2]-eta[3]),-1/(eta[i-1]-eta[i])+1/(eta[i]-eta[i+1]),-1/(eta[n-1]-eta[n]))}

hess.pen.par1 <- function(eta){
  n     <- length(eta)    
  i     <- 3:(n-1)
  
  h1    <- c(0,0,(eta[2:(n-1)]-eta[3:n])^(-2),0)
  h2    <- diag(h1)[-1,-(n+1)]
  hd    <- diag(c(0,-(eta[2]-eta[3])^(-2),-(eta[i-1]-eta[i])^(-2)-(eta[i]-eta[i+1])^(-2),-1/(eta[n-1]-eta[n])^2))
  H     <- hd+t(h2)+h2
  H}

#============= Newton-step for log-barrier algorithm =========================================
newton.par1.lb <- function(dx,eta,mu,G){
  n     <- length(eta)
  m     <- n-2
  dL    <- an.grad.par1(dx,eta)       
  H     <- an.hess.par1(dx,eta)
  s     <- -as.vector(G%*%eta)
  S     <- diag(1/s)
  h     <- dL/mu+t(G)%*%(1/s) 
  Q     <- H/mu+t(G)%*%(S^2%*%G)
  p     <- -solve(Q,tol=10^-20)%*%h
  p}

#============= Newton-step (interior point algorithm) =============================================
newton.par1.ip <- function(n,mu,z,G,dL,H){
  m     <- n-2
  eta   <- z[1:n]
  s     <- z[(n+1):(n+m)]
  v     <- z[(n+m+1):(n+2*m)]
  ee    <- rep(1,m)
  S     <- diag(s)
  S1    <- solve(S,tol=10^-20)       #m*m, G:n*m
  V     <- diag(v)        #m*m
  
  deta <- -solve(H+t(G)%*%(V%*%S1)%*%G,tol=10^-20)%*%(dL+t(G)%*%v-t(G)%*%S1%*%(V%*%s-mu*ee)+t(G)%*%(V%*%S1)%*%(G%*%eta+s))
  ds    <- -G%*%eta-s-G%*%deta
  dv    <- -S1%*%(V%*%s-mu*ee)-V%*%S1%*%ds
  dz    <- rbind(deta,ds,dv)
  dz}

#== divers auxiliary functions for derivatives =======
alpha <- function(dx,eta){c(0,(dx*eta)[-1])}
beta <- function(dx,eta){exp(cumsum(alpha(dx,eta)))}

#== 3rd summand in L: ==============
f.star <- function(j,dx,eta){sum(1/eta[j]*(beta(dx,eta)[j]-beta(dx,eta)[j-1]))}

#== Likelihood-function: ===========
Lhat.par1 <- function(dx,eta){
  n <- length(eta)
  L <- -n*eta[1]-sum((n-2:n+1)*alpha(dx,eta)[2:n])+n*exp(eta[1])*f.star(2:n,dx,eta)
  L}

#== Gradient of L: =================
an.grad.par1 <- function(dx,eta){
  n <- length(eta)                        
  dL2n <- 1:n*NA
  H0 <- n*exp(eta[1])
  dL1 <- n-H0*f.star(2:n,dx,eta)
  
  a <- alpha(dx,eta)
  b <- beta(dx,eta)
  k <- 2:n
  temp <- (dx*rev(cumsum(rev(c(0,1/eta[3:n]*(b[3:n]-b[2:(n-1)]),0)))))[k]    
  dL2n[k] <- (n-k+1)*dx[k]-H0*(-eta[k]^(-2)*(b[k]-b[k-1])+1/eta[k]*(dx[k]*b[k])+temp) 
  G <- c(dL1,dL2n[2:n])
  -G}

#== Diagonal of Hesse of L : =======
an.hess.par1 <- function(dx,eta){
  n <- length(eta)            
  d22n <- 1:n*NA
  H0 <- n*exp(eta[1])
  d21 <- -H0*f.star(2:n,dx,eta)
  
  a <- alpha(dx,eta)
  b <- beta(dx,eta)
  k <- 2:n
  temp <- (dx^2*rev(cumsum(rev(c(0,1/eta[3:n]*(b[3:n]-b[2:(n-1)]),0)))))[k]    
  d22n[k] <- -H0*(2*eta[k]^(-3)*(b[k]-b[k-1])-2*eta[k]^(-2)*(dx[k]*b[k])+dx[k]^2*b[k]/eta[k]+temp)    
  H <- c(d21,d22n[2:n])
  -diag(H)}

#============= Lagrange-function phi2.par1 (log-barrier algorithm) ===========================
# calculates Lagrange-function in log-barrier algorithm for a fixed mu
phi2.par1   <- function(mu,dx,eta){-Lhat.par1(dx,eta)-mu*pen.par1(eta)}

#============= norm calculated in norm induced by Hessian of Lagrange function ===============
# calculates Lagrange-function in log-barrier algorithm for a fixed mu
normH.par1  <- function(dx,p,eta){
  H <- -an.hess.par1(dx,eta)-hess.pen.par1(eta)
  (t(p)%*%H%*%p)^0.5}

############################################
# Auxiliary functions for problemadapted #
############################################

#================= phieta.par2(x,phi), etaphi.par2(x,eta) ===================================
# Changes between different parametrisations
phieta.par2 <- function(x,phi){ 
  n <- length(x)
  theta <- c(NA,diff(phi)/diff(x))
  eta <- c(phi[1],theta[2],theta[2:(n-1)]-theta[3:n])}

etaphi.par2 <- function(x,eta){
  n <- length(x)
  dx <- c(0,diff(x))
  theta <- c(0,eta[2],eta[2]-cumsum(eta[3:n]))
  phi <- eta[1]+c(0,eta[2]*dx[2],cumsum((theta*dx)[2:n])[-1])}

#================= starter.par2(x) ==========================================================
# start vector: fitted values for a model log(kern(x))~1+x+log(x) (corresponds to Gamma density)
starter.par2 <- function(x){
  X <- cbind(1,x,x^2)
  H <- X%*%solve(t(X)%*%X)%*%t(X)
  phi <- H%*%(log(kern(x)))
  
  # it can happen that phi is convex instead of concave (e.g. when the true density is uniform)
  d <- diff(phi)/diff(x)
  if (d[2]<d[3]){phi <- -phi}
  
  eta <- phieta.par2(x,phi)
  eta}

#-- Likelihood-function: --
Lhat.par2 <- function(x,dx,eta){
  n <- length(eta)
  i <- 2:n
  k <- 3:n        
  phi <- etaphi.par2(x,eta)
  L <- sum(phi)-n*sum(dx[i]/(phi[i]-phi[i-1])*(exp(phi[i])-exp(phi[i-1])))
  -L}

#-- Gradient of L: -------
an.grad.par2 <- function(x,dx,eta){
  n <- length(eta)
  e <- eta
  k <- 3:n    
  a <- c(NA,0,cumsum(e[-c(1:2)]))  
  b <- c(NA,0,cumsum(e[3:n]*x[2:(n-1)]))  
  
  exp1 <- c(NA,NA,exp(e[2]*(x[k]-x[1])-(a*x-b)[k]))
  exp2 <- c(NA,NA,exp(e[2]*(x[k-1]-x[1])-(a*x-b)[k-1]))
  exp.diff <- exp1-exp2
  
  dL <- 1:n*0
  
  dL[1] <- n-n*exp(e[1])*((exp(e[2]*dx[2])-1)/e[2]+sum(exp.diff[k]/(e[2]-a[k])))
  dL[2] <- -(n-1)*x[1]+sum(x[2:n])-n*exp(e[1])*(exp(e[2]*dx[2])*(dx[2]/e[2]-e[2]^(-2))+e[2]^(-2)+sum(((x[k]-x[1])/(e[2]-a[k])-(e[2]-a[k])^(-2))*exp1[k]-((x[k-1]-x[1])/(e[2]-a[k])-(e[2]-a[k])^(-2))*exp2[k]))                                               
  
  temp <- c(NA,NA,rep(0,n-2))
  for (j in 3:(n-1)){
    index <- (j+1):n
    temp[j] <- sum((e[2]-a[index])^(-2)*exp.diff[index]+((x[j-1]-x[index])*exp1[index]-(x[j-1]-x[index-1])*exp2[index])/(e[2]-a[index]))+(e[2]-a[j])^(-2)*exp.diff[j]-exp1[j]*dx[j]/(e[2]-a[j])
  }
  temp[n] <- dx[n]+(e[2]-a[n])^(-2)*exp.diff[n]-exp1[n]*dx[n]/(e[2]-a[n])
  dL[k] <- (n-k+1)*x[k-1]-(c(NA,NA,rev(cumsum(rev(x[k]))))[k])-n*exp(e[1])*temp[k]
  -dL}


# Calculation of complete Hesse Matrix
#
# x:        data
# dx:       diff(x)
# eta:      current estimator
# dL:       current gradient
# sub:      sub-square-matrix of Hessian to be calculated (in order to save time in case not the whole is needed)
# diag:     0: whole Hesse is calculated
#           1: only matrix containing Hesse diagonal is calculated

#-- Hessian of L: --------
an.hess.par2.compl <- function(x,dx,eta,dL,sub=1:n,diag=1){
  n <- length(eta)    
  sub <- unique(c(1,2,sub))
  e <- eta
  k <- 3:n
  a <- c(NA,0,cumsum(e[-c(1:2)]))  
  b <- c(NA,0,cumsum(e[3:n]*x[2:(n-1)]))  
  v <- 1/(e[2]-a)
  
  exp1 <- c(NA,NA,exp(e[2]*(x[k]-x[1])-(a*x-b)[k]))
  exp2 <- c(NA,NA,exp(e[2]*(x[k-1]-x[1])-(a*x-b)[k-1]))
  exp.diff <- exp1-exp2
  
  d2 <- diag(1:n*0)
  
  d2[1,1] <- -n*exp(e[1])*((exp(e[2]*dx[2])-1)/e[2]+sum(exp.diff[k]*v[k]))
  d2[2,2] <- -n*exp(e[1])*(exp(e[2]*dx[2])*(dx[2]^2/e[2]-2*dx[2]/e[2]^2+2/e[2]^3)-2/e[2]^3+sum((-2*(x[k]-x[1])*v[k]^2+2*v[k]^3+(x[k]-x[1])^2*v[k])*exp1[k]+(2*(x[k-1]-x[1])*v[k]^2-2*v[k]^3-(x[k-1]-x[1])^2*v[k])*exp2[k]))                                               
  
  temp <- c(NA,NA,rep(0,n-2))
  temp2 <- temp
  
  #Running variable, maximal range 3:(n-1), but only subset
  ber <- unique(c(sub,1,2,n))
  ber <- ber[-c(1,2,length(ber))] 
  
  for (j in ber){
    index <- (j+1):n      
    
    #Diagonal of Hesse
    temp[j] <- 2*v[j]^3*exp.diff[j]+exp1[j]*dx[j]^2*v[j]-2*exp1[j]*dx[j]*v[j]^2+sum(2*v[index]^3*exp.diff[index]+exp1[index]*(2*(x[j-1]-x[index])/(e[2]-a[index])^2+(x[j-1]-x[index])^2/(e[2]-a[index]))-exp2[index]*(2*v[index]^2*(x[j-1]-x[index-1])+(x[j-1]-x[index-1])^2*v[index]))
    
    #From here on: only necessary when whole Hesse is desired
    if (diag==0){   
      #Derivative wrt eta_2
      temp2[j] <- -2*v[j]^3*exp.diff[j]+v[j]^2*(exp1[j]*(x[j]-x[1])-exp2[j]*(x[j-1]-x[1]))+v[j]^2*exp1[j]*dx[j]-v[j]*dx[j]*exp1[j]*(x[j]-x[1])+sum(-2*v[index]^3*exp.diff[index]+v[index]^2*(exp1[index]*(x[index]-x[1])-exp2[index]*(x[index-1]-x[1]))-v[index]^2*(exp1[index]*(x[j-1]-x[index])-exp2[index]*(x[j-1]-x[index-1]))+v[index]*(exp1[index]*(x[index]-x[1])*(x[j-1]-x[index])-exp2[index]*(x[index-1]-x[1])*(x[j-1]-x[index-1])))
      
      #Derivative wrt eta_j*eta_k f?r j=3,...,n-1 und k=j+1,...,n
      temp3 <- 2*v[index]^3*exp.diff[index]+v[index]^2*(exp1[index]*(-dx[index]))+v[index]^2*(exp1[index]*(x[j-1]-x[index])-exp2[index]*(x[j-1]-x[index-1]))+v[index]*(exp1[index]*(-dx[index])*(x[j-1]-x[index]))
      sumi <- (j+2):n
      temp4 <- 2*v[sumi]^3*exp.diff[sumi]-2*x[sumi]*v[sumi]^2*exp1[sumi]+2*exp2[sumi]*x[sumi-1]*v[sumi]^2+x[j-1]*v[sumi]^2*exp.diff[sumi]-v[sumi]*(exp1[sumi]*(x[j-1]-x[sumi])*x[sumi]-exp2[sumi]*(x[j-1]-x[sumi-1])*x[sumi-1])
      temp5 <- v[sumi]*(exp1[sumi]*(x[j-1]-x[sumi])-exp2[sumi]*(x[j-1]-x[sumi-1]))+v[sumi]^2*exp.diff[sumi]
      temp6 <- 0
      temp7 <- 0      
      
      if (j<(n-1)){
        temp6 <- c(rev(cumsum(rev(temp4))),0)
        temp7 <- c(x[index[-(n-j)]-1]*rev(cumsum(rev(temp5))),0)}
      
      d2[j,index] <- -n*exp(e[1])*(temp3+temp6+temp7)
      d2[index,j] <- d2[j,index]}}
  
  temp[n] <- 2*v[n]^3*exp.diff[n]-2*exp1[n]*dx[n]*v[n]^2+exp1[n]*dx[n]^2*v[n]
  diag(d2)[k] <- -n*exp(e[1])*temp[k]
  
  if (diag==0){
    d2[1,2] <- -dL[2]+(n-1)*x[1]-sum(x[2:n])
    d2[2,1] <- d2[1,2]  
    
    d2[1,k] <- -dL[k]-(n-k+1)*x[k-1]+(sum(x[k])-c(0,cumsum(x[3:(n-1)])))
    d2[k,1] <- d2[1,k]  
    
    #From diagonal
    temp2[n] <- -2*v[n]^3*exp.diff[n]+v[n]^2*(exp1[n]*(x[n]-x[1])-exp2[n]*(x[n-1]-x[1]))+v[n]^2*exp1[n]*dx[n]-v[n]*dx[n]*exp1[n]*(x[n]-x[1])
    d2[2,k] <- -n*exp(e[1])*temp2[k]
    d2[k,2] <- d2[2,k]} 
  
  -d2[sub,sub]}

#################################
# Auxiliary function for icma #
#################################

isoMean <- function(y,w){
  
  # Pool-adjacent-violaters-algorithm for a weighted
  # mean.  
  #
  # Input:
  #   - y     : data points                                       
  #   - w     : corresonding weights                      
  
  n <- length(y)
  k <- 1:n*0
  gew <- 1:n*0
  ghat <- 1:n*0
  c <- 1
  k[c] <- 1
  gew[c] <- w[1]
  ghat[c] <- y[1]
  
  for (j in 2:n){     
    c <- c+1
    k[c] <- j
    gew[c] <- w[j]
    ghat[c] <- y[j]
    
    while (c>=2 && ghat[max(1,c-1)]>=ghat[c]){
      neu <- gew[c]+gew[c-1]
      ghat[c-1] <- ghat[c-1]+(gew[c]/neu)*(ghat[c]-ghat[c-1])
      gew[c-1] <- neu
      c <- c-1}}
  
  while (n>=1){
    for (j in k[c]:n){ghat[j] <- ghat[c]}
    n <- k[c]-1
    c <- c-1}
  ghat}
